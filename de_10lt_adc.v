
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================
//signal tap: presentis filer, post-fitting explain. use technology map viewer(post fitting)
//https://www.google.com/search?q=how+to+use+quartus+signal+tap&sxsrf=AB5stBj1vtQdP_DwmtMZclH0nr08jmw89Q%3A1691613086685&source=hp&ei=nvfTZNO4JoKx0PEP2Y--kAo&iflsig=AD69kcEAAAAAZNQFrjnNi4pQviLX1-3EAYLB2-9QRIkK&ved=0ahUKEwjT_4DptdCAAxWCGDQIHdmHD6IQ4dUDCAs&uact=5&oq=how+to+use+quartus+signal+tap&gs_lp=Egdnd3Mtd2l6Ih1ob3cgdG8gdXNlIHF1YXJ0dXMgc2lnbmFsIHRhcDIGEAAYFhgeMggQABiKBRiGAzIIEAAYigUYhgMyCBAAGIoFGIYDSLqXAVAAWMGPAXABeACQAQCYAacBoAH9GaoBBDguMjG4AQPIAQD4AQHCAgcQIxiKBRgnwgIEECMYJ8ICCBAAGIoFGJECwgILEC4YgAQYsQMYgwHCAhEQLhiABBixAxiDARjHARjRA8ICCxAAGIAEGLEDGIMBwgIFEAAYgATCAgcQABiKBRhDwgIFEC4YgATCAgsQABiKBRixAxiDAcICCBAAGIAEGLEDwgILEAAYFhgeGA8Y8QTCAggQABgWGB4YDw&sclient=gws-wiz#kpvalbx=_tPfTZLilGq6eptQPnfiuoAU_28
//https://www.intel.com/content/www/us/en/docs/programmable/683091/20-1/typical-read-and-write-transfers.html
// Determine the next state synchronously, based on the
// current state and the input
//https://verilogguide.readthedocs.io/en/latest/verilog/fsm.html

module DE_10LT_ADC(

	//////////// CLOCK //////////
	input 		          		ADC_CLK_10,
	input 		          		MAX10_CLK1_50,
	input 		          		MAX10_CLK2_50,

	//////////// SEG7 //////////
	output		     [7:0]		HEX0,
	output		     [7:0]		HEX1,
	output		     [7:0]		HEX2,
	output		     [7:0]		HEX3,
	output		     [7:0]		HEX4,
	output		     [7:0]		HEX5,

	//////////// KEY //////////
	input 		     [1:0]		KEY,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// SW //////////
	input 		     [9:0]		SW
);

//The ADC block uses the device PLL as the clock source. The ADC clock path is a dedicated clock path. You cannot change this clock path.


pll1	pll1_inst (
	.areset ( !KEY[0] ),
	.inclk0 ( MAX10_CLK1_50 ),
	.c0 ( c0_10MHZ ),//clock used for jtag and adc
	.c1 ( c1_100kHZ ),//clock used for DDS
	.locked ( locked_sig )
	);
	
	
	adc_core u0 (
		.clock_clk              (MAX10_CLK1_50),              // clock.clk
		.reset_sink_reset_n     (KEY[0]),     						// reset_sink.reset_n
		.adc_pll_clock_clk      (c0_10MHZ),      					// adc_pll_clock.clk
		.adc_pll_locked_export  (locked_sig),  					// adc_pll_locked.export
		.command_valid          (command_valid),          		// command.valid
		.command_channel        (/*command_channel*/5'b00001),// input  wire [4:0] .channel
		.command_startofpacket  (command_startofpacket),  		// .startofpacket
		.command_endofpacket    (command_endofpacket),    		//  .endofpacket
		.command_ready          (command_ready ),          	// output wire .ready
		.response_valid         (response_valid),         		//response.valid
		.response_channel       (response_channel),       		//output wire [4:0].channel
		.response_data          (response_data),          		// output wire [11:0] .data
		.response_startofpacket (response_startofpacket), 		//.startofpacket
		.response_endofpacket   (response_endofpacket)    		//.endofpacket
	);
	
SEG7_LUT_6 display(	
	.oSEG0(HEX0),
	.oSEG1(HEX1),
	.oSEG2(HEX2),
	.oSEG3(HEX3),
	.oSEG4(HEX4),
	.oSEG5(HEX5),
	.iDIG(wrdata_to_jtag)//display adc values and device seetings
);	

jtag_uart_comm jtag_uart_comm_inst
(
	.clk_10MHz(c0_10MHZ) ,	// input  clk_10MHz_sig
	.reset_n(KEY[0]) ,		// input  reset_n_sig
	.trigger(trigger_sig) ,	// input  trigger_sig
	.jtag_wrdata_to_jtag(wrdata_to_jtag),//[23:0]
	.data(readdata),
	.vjtag_udr() ,				// output  vjtag_udr_sig
		.toggle(toggle_bit_1sec)
);

DDS DDS_inst
(
	.clk(c1_100kHZ) ,		// input  clk_sig
	.reset_n(KEY[0]) ,	// input  reset_n_sig
	.in() ,					// input [31:0] in_sig
	.out(DDS_out_sig) 	// output [11:0] out_sig
);


//=======================================================
//  REG/WIRE declarations
//=======================================================
//https://www.intel.com/content/www/us/en/programmable/quartushelp/18.1/index.htm#hdl/vhdl/vhdl_file_dir.htm
wire [4:0] response_channel/* synthesis keep */;
wire [4:0] reg_response_channel/* synthesis keep */;
wire [11:0]    response_data/* synthesis keep */;
reg [11:0]    reg_response_data=0/* synthesis noprune */;

wire [11:0] DDS_out_sig/* synthesis keep */;

(*preserve = 1*)reg [3:0] state,stateAx,stateTx;
reg [3:0] rx_state/* synthesis keep */;
reg [31:0] count_wait/* synthesis noprune */;

reg reg_command_startofpacket /* synthesis noprune */;
reg reg_command_valid /* synthesis noprune */;
reg reg_command_ready /* synthesis noprune */;
wire response_valid /* synthesis keep */;
wire response_startofpacket /* synthesis keep */;
wire response_endofpacket /* synthesis keep */;

(*preserve = 1*) reg [12:0] adcval  ;	

/*(*keep=1*)*/ wire [31:0] readdata/* synthesis keep */;
/*(*keep = 1*)*/ reg [7:0] wrdata/* synthesis keep */ ;
wire trigger_sig /* synthesis keep */;

//=======================================================
//  ADC
//=======================================================	
//ug_m10_adc-683596-743729.pdf	
	
parameter S0 = 0, S1 = 1, S2 = 2, S3 = 3, S4=4, S5=5, S6=6, S7 = 7, S8 = 8, S9= 9, S10 = 10,S11=11,S12=12,S13=13;

//=======================================================
//  Structural coding
//=======================================================

integer divisor,divisor_1,counter/* synthesis keep */;
wire sample_counter_match/* synthesis keep */;
integer sample_counter/* synthesis keep */;
reg [4:0] Tdiv_cmd /* synthesis noprune */;
reg [4:0]Acquisition_cmd /* synthesis noprune */;
reg [9:0] adc_data_count /* synthesis noprune */;
reg [11:0] trigger_level/* synthesis keep */;
reg trigger_enable/* synthesis keep */;


initial begin
	counter=1;
	adc_data_count=0;
	divisor  = 100000;
	divisor_1= 100000;
	Tdiv_cmd=18;//1[s]/div
	trigger_level=0;//82==.1v
	trigger_enable=1'b0;

end

always @ (posedge c0_10MHZ ) begin
	case (Tdiv_cmd)
		
// 1MHZ sample rate		
		//us


//			5'd1:divisor=1;//5[us]/div  //these options are not avaialble due to data transmission length. I FIFO is required to buffer the acquired data
//			5'd2:divisor=2;//10[us]/div
//			5'd3:divisor=4;//20[us]/div
//			5'd4:divisor=6;//30[us]/div
//			5'd5:divisor=10;//50[us]/div
//			5'd6:divisor=20;//100[us]/div
			
			5'd7:divisor=50;//250[us]/div
			5'd8:divisor=100;//500[us]/div
			5'd9:divisor=200;//1[ms]/div
			5'd10:divisor=500;//2.5[ms]/div
			5'd11:divisor=1000;//5[ms]/div
			5'd12:divisor=2000;//10[ms]/div
			5'd13:divisor=5000;//25[ms]/div
			5'd14:divisor=10000;//50[ms]/div
			5'd15:divisor=20000;//100[ms]/div
			5'd16:divisor=50000;//250[ms]/div
			5'd17:divisor=100000;//500[ms]/div
			5'd18:divisor=200000;//1[s]/div
			5'd19:divisor=500000;//2.5[s]/div
			5'd20:divisor=1000000;//5[s]/div
			5'd21:divisor=2000000;//10[s]/div
			5'd22:divisor=5000000;//25[s]/div
			5'd23:divisor=10000000;//50[s]/div


		default : divisor=200000;//1[s]/div
	endcase

end


reg [23:0] wrdata_to_jtag /* synthesis noprune */;

// handles time division commands from PC
always @ (posedge c0_10MHZ ) begin
	if(readdata[4:0]>=5'd1 & readdata[4:0]<=5'd23)
		Tdiv_cmd=readdata[4:0];
end

// handles acquisition commands division commands from PC
// Start acquisition:31d or 1fh
// Packet received:30d or 1eh
always @ (posedge c0_10MHZ ) begin
	if(readdata[4:0]==5'd30 | readdata[4:0]==5'd31)
		Acquisition_cmd=readdata[4:0];
end

reg upload_data_start/* synthesis keep */;

initial upload_data_start=1'b0;

parameter A0 = 0, A1 = 1, A2 = 2, A3 = 3,A4 = 4,A5 = 5, A6=6,A7=7, A8=8, A9=9, A10=10, A11=11, A12=12; /*, A13=13, A14=14, A15=15, A16=16;*/

// This process controls the data acquisition from ADC
always @ (posedge c0_10MHZ ) begin


	case (stateAx)
				A0:
					if (Acquisition_cmd==5'h1f /*| KEY[1]==1'b0*/) 
						stateAx = A1;
					else
						upload_data_start=1'b0;
					
				A1:
					begin
						if (SW[9]==1'b1)//override synch signal
							stateAx = A5;
						else if(synch_sample==1'b0)
							stateAx = A2;
						else
							stateAx = A4;
					end	
				A2:
					begin
						if(synch_sample==1'b1)
							stateAx = A5;
					end	
				A4:
					begin
						if(synch_sample==1'b0)
							stateAx = A5;
					end	
				A5:
					begin
							if(trigger_enable==1'b0) 
								stateAx = A7;
							else if(reg_response_data<=trigger_level) // if triggering on signal level wait for value transition
								stateAx = A6;
					end	
				A6:
					begin
							if(reg_response_data>=trigger_level)  // if triggering on signal level wait for value transition
								stateAx = A7;
					end
				A7:
					begin
						upload_data_start=1'b1;  //finally enable data acquisition process
						stateAx = A8;
					end
					
				A8:
					begin
							if(adc_data_count==1 )////////// wait for the first sample count
								stateAx = A9;
					end						
				A9:
					begin
							if(adc_data_count==0  )////////// wait for 	 of last sample count
									stateAx = A10;
					end	
				A10:
						stateAx = A11;
				A11:
					begin
						upload_data_start=1'b0;
						stateAx = A12;
					end
				A12:
					if (Acquisition_cmd==5'h1e/*| KEY[1]==1'b0*/) 
						stateAx = A0;
	endcase

end


// Synch acquisition signal with ADC sample. Not really required. But nice to have the sample always at the same points
reg synch_sample;
initial synch_sample=1'b0;
always @ (posedge response_valid ) begin
	synch_sample=!synch_sample;
end



parameter T0 = 0, T1 = 1, T2 = 2, T3 = 3,T4 = 4,T5 = 5;


//This porcess handles the trigger commands from the PC
//Increase trigger level :h1d 
//Decrease trigger level :h1b
//Enable  trigger : h1a
//Disable  trigger : h1b
always @ (posedge c0_10MHZ ) begin


	case (stateTx)
				T0:
					if (readdata[4:0]==5'h1d )//increment 
						stateTx = T1;
					else if(readdata[4:0]==5'h1c)//decrement
						stateTx = T2;
					else if(readdata[4:0]==5'h1b)//disable trigger
						stateTx = T3;
					else if(readdata[4:0]==5'h1a)//enable trigger
						stateTx = T4;
						
				T1:
					begin
						trigger_level = trigger_level+64;//0.0390625v
						stateTx = T5;
					end
					
				T2:
					begin
						trigger_level = trigger_level-64;//-0.0390625v
						stateTx = T5;
					end
				T3:
					begin
						trigger_enable = 1'b0;
						stateTx = T5;
					end
				T4:
					begin
						trigger_enable = 1'b1;
						stateTx = T5;
					end
				T5:
					if (readdata[4:0]==5'h00) 
						stateTx = T0;
				default: stateTx=0;
	endcase

end

// This process handles the timing fo the sampling rate based on time per division.
//ADC samples every 1us but data is acquired when counter matches the sampling rate choosen
always @ (posedge c0_10MHZ) begin
 	
		if(sample_counter==divisor|sample_counter>divisor|upload_data_start==1'b0)
			sample_counter=1;
		else 
			sample_counter=sample_counter+1;
end


// This process counts the datapoints acquired from the ADC
// The datasamples are same size as the picturebox in the C# application.
assign sample_counter_match =(sample_counter==divisor)?1'b1:1'b0;
localparam MAX_ADC_SAMPLES = 600;
always @ (negedge sample_counter_match) begin

		if(adc_data_count==MAX_ADC_SAMPLES)
			adc_data_count=0;
		else
			adc_data_count=adc_data_count+1;
			
end

 


// This process saves the acquired data to register for transmission to PC through the JTAG UART
//data number 1 give parameter settings when waiting to start acquisition.
//when acquisiion starts ADC data is registered
// Thee bytes is sent. they contain ADC readings, data counter etc.
always @ (posedge c0_10MHZ  ) begin
	if (adc_data_count==0 & counter==1)//pattern indicating start of adc samples packet
		wrdata_to_jtag={5'b1111_1,Tdiv_cmd,SW[0],trigger_enable,trigger_level};//24'hf5;//return device settings  
	else if (adc_data_count>0 & counter==1)
		wrdata_to_jtag={2'b00,adc_data_count,reg_response_data};//contains sample number from 1-600 and 12-bit samples

end


assign trigger_sig=(sample_counter==3 & upload_data_start==1'b1)?1'b1:1'b0;//Tells JTAG to read registered data and transmit to PC through JTAG

assign		command_valid =reg_command_valid;
assign		command_startofpacket =reg_command_startofpacket;
assign		command_ready = reg_command_ready;

// This process kickstarts the ADC channel 0 at default 1MHZ sample rate(1us)
	always @ (posedge MAX10_CLK1_50 ) begin
		if (!KEY[0])
			begin
					reg_command_valid=1'b0;
					reg_command_startofpacket=1'b0;
					reg_command_ready=1'b0;
					state = S0;
			end
		else
			case (state)//reset
				S0:
					if (/*!KEY[1] &*/ locked_sig)
					begin
						state = S1;
					end
					else
						begin
							reg_command_valid=1'b0;
						end
					 
				S1://CMD_SOP VALID
					begin
						reg_command_startofpacket=1'b1;
						reg_command_valid=1'b1;
						state = S2;
					end
				S2://NOP
					begin

						state = S3;
					end
					
				S3://CMD_READY 
					begin
						reg_command_ready=1'b1;
						state = S4;
					end
				S4://CMD_READY SOP END
					begin	
						reg_command_ready=1'b0;
						reg_command_startofpacket=1'b0;
						state = S5;
					end
 				
				S5:
					begin

							state = S5;
					end

			endcase
	end
	
	

assign LEDR[9]=toggle_bit_1sec;//Device Heartbeat indicator
assign LEDR[4:0]=readdata[4:0];//display tdiv selection on LEDS
//assign LEDR[8]=response_valid;


// This process stores ADC samples when SW0 is off and DDS signal when on
// DDS signal is used to test the development of the application and as digital test signal generator 
always @ (posedge response_valid ) begin
	if(!SW[0])
		reg_response_data=response_data;
	else if(SW[0])
		reg_response_data=DDS_out_sig;
//	adcval = response_data * 2 * 2500 / 4095;
end

endmodule

